<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Spark内存管理"><meta name="keywords" content="翻译,spark"><meta name="author" content="AlexanderKwong"><meta name="copyright" content="AlexanderKwong"><title>Spark内存管理 | AlexanderKwong</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spark内存管理"><span class="toc-number">1.</span> <span class="toc-text">Spark内存管理</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">AlexanderKwong</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://api.neweb.top/bing.php)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">AlexanderKwong</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Spark内存管理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-10-23</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="Spark内存管理"><a href="#Spark内存管理" class="headerlink" title="Spark内存管理"></a>Spark内存管理</h1><p>从1.6.0版本的spark开始，内存管理模型变更了。旧的内存管理模型是通过<a href="https://github.com/apache/spark/blob/branch-1.6/core/src/main/scala/org/apache/spark/memory/StaticMemoryManager.scala" target="_blank" rel="noopener">StaticMemortManager</a>类来实现的，而现在被称为“legacy“（遗产）。“legacy”模型默认是禁用的，注意，这就意味着在spark1.5.x和1.6.0上运行相同的代码会导致不同的结果。为了兼容性，你可以通过<code>spark.memory.useLegacyMode</code>参数启用“legacy”模型，默认是关着的。 </p>
<p>大约一年之前我有在这片<a href="https://0x0fff.com/spark-architecture/" target="_blank" rel="noopener">关于spark架构</a>的文章描述内存管理的“legacy”模型。我也写了一片文章<a href="https://0x0fff.com/spark-architecture-shuffle/" target="_blank" rel="noopener">关于Spark的Shuffle实现</a>的，也简单的提及了内存管理这个话题。 </p>
<p>这片文章讲述在apache spark 1.6版本开始使用的新的内存管理模型，它通过<a href="https://github.com/apache/spark/blob/branch-1.6/core/src/main/scala/org/apache/spark/memory/UnifiedMemoryManager.scala" target="_blank" rel="noopener">UnifieldMemoryManager</a>类来实现。 </p>
<p>长话短说，新内存模型看起来像是这样的： </p>
<img src="/2019/10/23/Spark%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/spark-memory-module.png" class="" title="Apache Spark Unified Memory Manager introduced in v1.6.0+">

<p>你可以在图中看到三个主要内存区域： </p>
<ol>
<li><p>保留内存（ReservedMemory）。这是系统保留内存，它的大小是硬编码的。自spark 1.6.0起它的值是300MB，意味着这300MB内存不会参与spark内存大小的计算中，以及它的大小不能被任何没有经过重新编译 spark或设置<code>spark.testing.reservedMemory</code>参数 的途径改变，其中由于后者是测试参数，没有打算用于产品中，所以是不建议的。注意了，这块内存仅仅是叫做“保留的”，而事实上它不会被spark以任何方式使用。但它设置了你能够分配给Spark使用的限制。即使你想要将所有的java堆内存给spark去缓存你的数据，你也做不到，因为这块“保留”区仍会空闲（不是真的空闲，他会存着大量的spark内部对象）。可供参考的是，如果你不给spark executor至少1.5*保留内存=450MB堆内存，它将有“please use larger heap size”的报错信息。 </p>
</li>
<li><p>用户内存（User Memory）。这是分给spark内存（第三点）后剩下的内存池，它完全是给你的，你可以以你喜欢的方式用它。你可以在那存储你自己的数据结构，以用于RDD转换中（transformations）。例如，你可以通过使用mapPartitions transformation维护哈希表进行聚合的方式重写spark的聚合（aggregation）方法，消耗的是用户内存，在Spark1.6.0这个内存池的大小可能以（java堆内存 - 保留内存）* （1.0 - <code>spark.memory.fraction</code>），默认等价于（java堆内存 - 300MB）* 0.25。例如，4GB的堆你会有949MB的用户内存。再强调一遍，这就是用户内存，它完全取决于你存什么和怎样存在这一块，spark完全不会统计你在这干嘛以及你是否意识到内存边界。代码没有考虑到这个问题可能导致OOM。 </p>
</li>
<li><p>spark内存（Spark Memory）。最后，这是由apache spark管理的内存池。它的大小可以通过（java堆内存 - 保留内存） * <code>spark.memory.fraction</code> 计算得到，spark1.6.0默认是（java堆内存 - 300MB）* 0.75。假设4GB堆内存的话这个池会有2847MB的大小。整个池会被分成两个区域——存储内存（Storage Memory）和执行内存（Execution Memory）,它们的边界由参数<code>spark.memory.storageFraction</code>来设置，默认是0.5。新的内存管理设计的优点是，这个边界不是静态的，万一内存压力过大时边界会移动。一个区域通过向另一个借空间的方式增加内存。我稍后会讨论边界的移动，现在让我们关注这块内存如何被使用： </p>
<ul>
<li><p>存储内存（Storage Memory）。这个池用来存spark的缓存数据和序列化“unroll”数据的临时空间。而且所有的广播变量也作为缓存块储存在这。以免你感到奇怪，这里时unroll的代码。正如你可以看到的，它不要求足够的内存来使铺开的块（unrolled block）变得可用——也许没有足够的内存去适配所有的unrolled partition，如果要求的持久化等级（persistence level）允许的话它会直接放进驱动（driver）。至于广播，所有的广播变量在MEMORY_AND_DISK的持久化等级下都存储在缓存。 </p>
</li>
<li><p>执行内存（Execution Memory）。这个池被用来存储执行spark任务（tasks）时要求的对象。例如，用来存储<a href="https://0x0fff.com/spark-architecture-shuffle/" target="_blank" rel="noopener">map端的shuffle中间缓冲</a>，它也被用来存储哈希聚合（hash aggregation）步骤用到的哈希表。如果没有足够的内存可用，这个池也支持溢写磁盘，但这个池中的块不能被其他线程（任务tasks）强制回收。 </p>
</li>
</ul>
</li>
</ol>
<p>好了，现在让我们关注在存储内存和执行内存间移动边界的问题。由于执行内存天然的特性，你不能从池中强制回收块，因为这些数据在中间计算时被使用了，那么进程需要这块内存时会因块丢失而失败。但对于存储内存来说就不是这样了，它只是存储在RAM的一份块缓存，如果我们从那回收了块我们只是更新了块的元数据，从而反映这个块被回收到硬盘（或简单地被移除），如果尝试访问这个块，spark会从硬盘读取（如果你的持久化等级不允许溢写磁盘的话将重新计算）。 </p>
<p>因此，我们可以从存储内存强制回收内存块，但对于执行内存就不能。那执行内存什么时候会从存储内存那“借”到空间？下面两个情况下就会： </p>
<ul>
<li><p>存储内存池中有可用的空闲的空间，也就是，缓存块没用光所有的可用内存。那么就会减少存储内存池的大小，增加执行内存池的大小。 </p>
</li>
<li><p>存储内存池大小超过了初始化的内存区块大小，而且所有的空间都被利用了。这种情况导致块从存储内存中被强制回收，直到它回到初始化的大小为止。 </p>
</li>
</ul>
<p>相应地，存储内存池仅在执行内存池中有可用的空闲的空间时才能“借”到一些空间。 </p>
<p>你可能记得，存储内存区初始化大小，是这样计算的：Spark内存 * <code>spark.memory.storageFraction</code> = （java堆内存 - 保留内存） * <code>spark.memort.fraction</code> * <code>spark.memory.storageFraction</code>。默认等于（java堆内存 - 300MB）  * 0.75 * 0.5 = （java堆内存 - 300MB）* 0.375对于4GB的堆内存，就有1423.5MB的RAM初始化为存储内存区域。 </p>
<p>这意味着如果我们用spark缓存和缓存在executor的数据总量至少是初始化的存储内存区域大小，我们保证存储区域大小至少有初始化时那么大，因为我们将不能够再从它那里回收数据以减少它的大小。但是，如果在你装满存储内存区之前，你的执行内存区域已经大得超出它初始化的大小，你就不能从执行内存中强制回收entries，所以当执行过程在内存中一直持有着内存块，你就只有更小的存储内存区了。 </p>
<p>我希望这篇文章能更好地帮到你明白apache spark内存管理原则，相应地设计你的应用程序。如果你有任何问题，可以在评论中提出。 </p>
<p>原文链接： <a href="https://0x0fff.com/spark-memory-management/" target="_blank" rel="noopener">https://0x0fff.com/spark-memory-management/</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">AlexanderKwong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://alexanderkwong.github.io/2019/10/23/Spark%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">https://alexanderkwong.github.io/2019/10/23/Spark%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a><a class="post-meta__tags" href="/tags/spark/">spark</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/10/23/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2SparkSql%E7%9A%84%E4%BC%98%E5%8C%96%E5%99%A8Catalyst/"><i class="fa fa-chevron-left">  </i><span>深入探索SparkSql的优化器Catalyst</span></a></div><div class="next-post pull-right"><a href="/2019/10/22/Spark%E6%9E%B6%E6%9E%84-Shuffle/"><span>Spark架构:Shuffle</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://api.neweb.top/bing.php)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By AlexanderKwong</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>